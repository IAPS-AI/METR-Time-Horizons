<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Measuring AI Ability to Complete Long Tasks | METR</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #f8fafc;
            color: #1e293b;
            line-height: 1.5;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            margin-bottom: 2rem;
        }

        h1 {
            font-size: 1.75rem;
            font-weight: 600;
            color: #0f172a;
        }

        .subtitle {
            color: #64748b;
            font-size: 0.95rem;
            margin-top: 0.25rem;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
        }

        .control-group label {
            font-size: 0.75rem;
            font-weight: 500;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.025em;
        }

        .control-group select,
        .control-group input {
            padding: 0.5rem 0.75rem;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 0.9rem;
            background: white;
            min-width: 140px;
        }

        .control-group input[type="number"] {
            width: 100px;
        }

        .control-group select:focus,
        .control-group input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding-top: 1.25rem;
        }

        .checkbox-group input[type="checkbox"] {
            width: 1rem;
            height: 1rem;
        }

        .checkbox-group label {
            font-size: 0.85rem;
            color: #475569;
            text-transform: none;
        }

        #plot {
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            margin-bottom: 1.5rem;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .stat-card {
            background: white;
            border-radius: 8px;
            padding: 1.25rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .stat-card h3 {
            font-size: 0.75rem;
            font-weight: 500;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.025em;
            margin-bottom: 0.5rem;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 600;
            color: #0f172a;
        }

        .stat-ci {
            font-size: 0.85rem;
            color: #64748b;
            margin-top: 0.25rem;
        }

        .stat-detail {
            font-size: 0.8rem;
            color: #94a3b8;
            margin-top: 0.5rem;
        }

        .model-comparison {
            color: #16a34a;
            font-weight: 500;
        }

        .calculator-section {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            margin-bottom: 1.5rem;
        }

        .calculator-section h2 {
            font-size: 1rem;
            font-weight: 600;
            color: #0f172a;
            margin-bottom: 1rem;
        }

        .calc-row {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            align-items: flex-end;
        }

        .calc-result {
            padding: 1rem;
            background: #f0fdf4;
            border: 1px solid #bbf7d0;
            border-radius: 6px;
            margin-top: 1rem;
        }

        .calc-result.warning {
            background: #fefce8;
            border-color: #fef08a;
        }

        .calc-result strong {
            color: #166534;
        }

        .calc-result.warning strong {
            color: #a16207;
        }

        .custom-scenarios {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            margin-top: 1rem;
        }

        .scenario-input {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .scenario-input input {
            width: 80px;
            padding: 0.4rem 0.6rem;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            font-size: 0.85rem;
        }

        .scenario-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .tab {
            padding: 0.5rem 1rem;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.15s;
        }

        .tab:hover {
            background: #f8fafc;
        }

        .tab.active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .loading {
            text-align: center;
            padding: 3rem;
            color: #64748b;
        }

        .methodology {
            font-size: 0.8rem;
            color: #64748b;
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid #e2e8f0;
        }

        footer {
            text-align: center;
            padding: 2rem;
            color: #64748b;
            font-size: 0.85rem;
        }

        footer a {
            color: #3b82f6;
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        #rawDataBody tr:hover {
            background: #f8fafc;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Measuring AI Ability to Complete Long Tasks</h1>
            <p class="subtitle">Tracking AI agent time horizons ‚Äî the amount of human work (on software/research tasks) that models can reliably automate</p>
        </header>

        <div class="controls">
            <div class="control-group">
                <label>Success Rate Threshold</label>
                <select id="horizonType">
                    <option value="p50">50% Success Rate</option>
                    <option value="p80">80% Success Rate</option>
                </select>
            </div>

            <div class="control-group">
                <label>Fit Data From</label>
                <select id="fitStartDate">
                    <option value="2019-01-01">2019</option>
                    <option value="2020-01-01" selected>2020</option>
                    <option value="2021-01-01">2021</option>
                    <option value="2022-01-01">2022</option>
                    <option value="2023-01-01">2023</option>
                </select>
            </div>

            <div class="control-group">
                <label>Project Until</label>
                <select id="endYear">
                    <option value="2026">2026</option>
                    <option value="2027">2027</option>
                    <option value="2028" selected>2028</option>
                    <option value="2029">2029</option>
                    <option value="2030">2030</option>
                </select>
            </div>

            <div class="checkbox-group">
                <input type="checkbox" id="showCI" checked>
                <label for="showCI">Show confidence intervals</label>
            </div>

            <div class="checkbox-group">
                <input type="checkbox" id="showProjection" checked>
                <label for="showProjection">Show projection</label>
            </div>

            <div class="checkbox-group">
                <input type="checkbox" id="showBootstrap" checked>
                <label for="showBootstrap">Bootstrap uncertainty</label>
            </div>
        </div>

        <div id="plot">
            <div class="loading">Loading benchmark data...</div>
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <h3>Time Horizon Doubling Rate</h3>
                <div class="stat-value" id="doublingTime">‚Äî</div>
                <div class="stat-ci" id="doublingTimeCI"></div>
                <div class="stat-detail" id="doublingTimeDetail"></div>
                <div class="stat-detail" style="margin-top: 0.25rem; font-style: italic;">Trend slope is more robust than individual model estimates</div>
            </div>

            <div class="stat-card">
                <h3>Exponential Fit Quality</h3>
                <div class="stat-value" id="rSquared">‚Äî</div>
                <div class="stat-ci" id="modelComparison"></div>
                <div class="stat-detail" id="fitDetail"></div>
            </div>

            <div class="stat-card">
                <h3>Current Frontier Time Horizon</h3>
                <div class="stat-value" id="currentHorizon">‚Äî</div>
                <div class="stat-ci" id="currentModel"></div>
                <div class="stat-detail" id="currentDetail"></div>
            </div>

            <div class="stat-card">
                <h3>Out-of-Sample Test</h3>
                <div class="stat-value" id="oosTest">‚Äî</div>
                <div class="stat-ci" id="oosDetail"></div>
                <div class="stat-detail">Predicting last 3 models from earlier data</div>
            </div>
        </div>

        <div class="calculator-section">
            <h2>Custom Growth Scenarios</h2>
            <p style="font-size: 0.85rem; color: #64748b; margin-bottom: 1rem;">
                Compare alternative doubling rates against the fitted trend. Enter 0 to disable a scenario.
            </p>
            <div class="custom-scenarios">
                <div class="scenario-input">
                    <span class="scenario-color" style="background: #e11d48;"></span>
                    <input type="number" id="custom1" placeholder="days" min="0" max="1000" value="0">
                    <span style="font-size: 0.8rem; color: #64748b;">days</span>
                </div>
                <div class="scenario-input">
                    <span class="scenario-color" style="background: #7c3aed;"></span>
                    <input type="number" id="custom2" placeholder="days" min="0" max="1000" value="0">
                    <span style="font-size: 0.8rem; color: #64748b;">days</span>
                </div>
                <div class="scenario-input">
                    <span class="scenario-color" style="background: #059669;"></span>
                    <input type="number" id="custom3" placeholder="days" min="0" max="1000" value="0">
                    <span style="font-size: 0.8rem; color: #64748b;">days</span>
                </div>
            </div>
        </div>

        <div class="calculator-section">
            <h2>Implied Doubling Time Calculator</h2>
            <p style="font-size: 0.85rem; color: #64748b; margin-bottom: 1rem;">
                Calculate the implied doubling rate from observed time horizon improvements.
            </p>

            <div class="tabs">
                <button class="tab active" data-tab="models">Between Models</button>
                <button class="tab" data-tab="dates">Between Dates</button>
            </div>

            <div id="models-tab" class="tab-content active">
                <div class="calc-row">
                    <div class="control-group">
                        <label>Earlier Model</label>
                        <select id="model1"></select>
                    </div>
                    <div class="control-group">
                        <label>Later Model</label>
                        <select id="model2"></select>
                    </div>
                </div>
                <div id="modelCalcResult" class="calc-result" style="display: none;"></div>
            </div>

            <div id="dates-tab" class="tab-content">
                <div class="calc-row">
                    <div class="control-group">
                        <label>Start Date</label>
                        <input type="date" id="calcStartDate">
                    </div>
                    <div class="control-group">
                        <label>End Date</label>
                        <input type="date" id="calcEndDate">
                    </div>
                </div>
                <div id="dateCalcResult" class="calc-result" style="display: none;"></div>
            </div>
        </div>

        <div class="calculator-section">
            <h2>Time Horizon Milestone Calculator</h2>
            <p style="font-size: 0.85rem; color: #64748b; margin-bottom: 1rem;">
                When will AI reliably complete tasks that take humans a given amount of time?
            </p>
            <div class="calc-row">
                <div class="control-group">
                    <label>Target Task Duration (Human Time)</label>
                    <select id="targetHorizon">
                        <option value="1">1 hour task</option>
                        <option value="4">4 hour task</option>
                        <option value="8" selected>8 hour task (1 workday)</option>
                        <option value="24">1 day task</option>
                        <option value="48">2 day task</option>
                        <option value="168">1 week task</option>
                        <option value="720">1 month task</option>
                    </select>
                </div>
            </div>
            <div id="milestoneResult" class="calc-result" style="display: none;"></div>
        </div>

        <div class="calculator-section">
            <h2>üîç Performance Gap Analysis</h2>
            <p style="font-size: 0.85rem; color: #64748b; margin-bottom: 1rem;">
                Compare performance between different model categories to understand accessibility gaps.
            </p>

            <div style="display: flex; flex-wrap: wrap; gap: 1rem; margin-bottom: 1rem;">
                <div>
                    <span style="font-size: 0.75rem; color: #64748b; text-transform: uppercase;">Comparison</span>
                    <div class="tabs" style="margin-top: 0.25rem;">
                        <button class="tab active" data-gap-tab="open_closed">Open vs Closed</button>
                        <button class="tab" data-gap-tab="china_us">China vs US</button>
                    </div>
                </div>
                <div>
                    <span style="font-size: 0.75rem; color: #64748b; text-transform: uppercase;">Gap Metric</span>
                    <div class="tabs" style="margin-top: 0.25rem;">
                        <button class="tab active" data-gap-metric="average">Average Gap</button>
                        <button class="tab" data-gap-metric="current">Current Gap (Est.)</button>
                    </div>
                </div>
            </div>

            <div class="stats-grid" style="margin-top: 1rem;">
                <div class="stat-card">
                    <h3 id="gapMetricLabel">Average Gap</h3>
                    <div class="stat-value" id="gapAvg">‚Äî</div>
                    <div class="stat-ci" id="gapAvgDetail"></div>
                    <div class="stat-detail" id="gapAvgExplainer" style="margin-top: 0.5rem;"></div>
                </div>
                <div class="stat-card">
                    <h3>Current Horizon Ratio</h3>
                    <div class="stat-value" id="gapRatio">‚Äî</div>
                    <div class="stat-ci" id="gapRatioDetail"></div>
                </div>
                <div class="stat-card">
                    <h3>Matched / Unmatched</h3>
                    <div class="stat-value" id="gapMatched">‚Äî</div>
                    <div class="stat-ci" id="gapMatchedDetail"></div>
                </div>
                <div class="stat-card">
                    <h3>Growth Rate Comparison</h3>
                    <div class="stat-value" id="gapTrend">‚Äî</div>
                    <div class="stat-ci" id="gapTrendDetail"></div>
                </div>
            </div>

            <details id="currentGapExplainer" style="margin-top: 1rem; display: none;">
                <summary style="cursor: pointer; font-weight: 500; color: #0f172a;">How is the current gap estimated?</summary>
                <div style="margin-top: 0.75rem; font-size: 0.85rem; color: #64748b; line-height: 1.7;">
                    <p>The <strong>average gap</strong> is based on historical matched pairs, but may underestimate the current gap because it doesn't account for models that haven't been matched yet.</p>
                    <p style="margin-top: 0.5rem;">The <strong>estimated current gap</strong> treats unmatched models as <strong>censored observations</strong> ‚Äî they tell us the gap is <em>at least</em> as long as their age.</p>
                    <p style="margin-top: 0.5rem;"><strong>Methodology (Survival Analysis):</strong></p>
                    <ol style="margin-left: 1.5rem; margin-top: 0.25rem;">
                        <li>Fit a log-normal distribution to historical matched gaps</li>
                        <li>For unmatched models, calculate E[gap | gap > age] using truncated log-normal</li>
                        <li>Weight by age (older unmatched models are more informative)</li>
                    </ol>
                    <p style="margin-top: 0.5rem;" id="gapMinBound"></p>
                </div>
            </details>

            <div id="gapPlot" style="margin-top: 1rem; min-height: 400px;"></div>

            <details style="margin-top: 1rem;">
                <summary style="cursor: pointer; font-weight: 600; color: #0f172a;">Gap Details</summary>
                <div style="margin-top: 1rem; overflow-x: auto;">
                    <table id="gapTable" style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
                        <thead>
                            <tr style="border-bottom: 2px solid #e2e8f0;">
                                <th style="text-align: left; padding: 0.5rem; color: #64748b;" id="gapLeadingHeader">Leading Model</th>
                                <th style="text-align: left; padding: 0.5rem; color: #64748b;">Date</th>
                                <th style="text-align: right; padding: 0.5rem; color: #64748b;">Horizon</th>
                                <th style="text-align: left; padding: 0.5rem; color: #64748b;" id="gapLaggingHeader">Lagging Model</th>
                                <th style="text-align: left; padding: 0.5rem; color: #64748b;">Matched Date</th>
                                <th style="text-align: right; padding: 0.5rem; color: #64748b;">Gap</th>
                            </tr>
                        </thead>
                        <tbody id="gapTableBody">
                        </tbody>
                    </table>
                </div>
            </details>

            <details style="margin-top: 1rem;">
                <summary style="cursor: pointer; font-weight: 600; color: #0f172a;">Model Classification</summary>
                <div style="margin-top: 1rem; overflow-x: auto;">
                    <table id="classificationTable" style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
                        <thead>
                            <tr style="border-bottom: 2px solid #e2e8f0;">
                                <th style="text-align: left; padding: 0.5rem; color: #64748b;">Model</th>
                                <th style="text-align: left; padding: 0.5rem; color: #64748b;">Family</th>
                                <th style="text-align: left; padding: 0.5rem; color: #64748b;">Type</th>
                                <th style="text-align: left; padding: 0.5rem; color: #64748b;">Region</th>
                                <th style="text-align: right; padding: 0.5rem; color: #64748b;">Horizon</th>
                            </tr>
                        </thead>
                        <tbody id="classificationTableBody">
                        </tbody>
                    </table>
                </div>
                <div class="methodology" style="margin-top: 1rem;">
                    <strong>Classification Rules:</strong><br>
                    ‚Ä¢ <strong>Open-weight families:</strong> DeepSeek, Alibaba (Qwen), Meta (LLaMA), Mistral<br>
                    ‚Ä¢ <strong>Open-weight patterns:</strong> Model names containing "oss", "open", "llama", "mistral"<br>
                    ‚Ä¢ <strong>Manual overrides:</strong> GPT-2 (open), Kimi K2 (open)
                </div>
            </details>
        </div>

        <div class="calculator-section">
            <h2>Methodology & Limitations</h2>
            <div style="font-size: 0.85rem; color: #64748b; line-height: 1.7;">
                <p><strong>Time Horizon:</strong> The amount of serial human labor (on software/research tasks) that AI can replace at the selected success rate. A 50% time horizon of 4 hours means the model succeeds 50% of the time on tasks that take skilled humans 4 hours to complete.</p>
                <p style="margin-top: 0.75rem;"><strong>Key Limitations:</strong> Individual model estimates have wide confidence intervals (~2x in each direction). Performance varies dramatically across domains ‚Äî these benchmarks focus on software and research tasks. The long-term trend slope is more robust than specific model measurements. Success rates don't directly translate to automation viability; reliability-critical applications may require 98%+ accuracy. See <a href="https://metr.org/notes/2026-01-22-time-horizon-limitations/" target="_blank" style="color: #3b82f6;">METR's detailed limitations notes</a>.</p>
                <p style="margin-top: 0.75rem;"><strong>Weighted Least Squares:</strong> Each model is weighted by the inverse variance of its horizon estimate (derived from 95% CI). Models with tighter confidence intervals have more influence on the fit.</p>
                <p style="margin-top: 0.75rem;"><strong>Bootstrap Confidence Intervals:</strong> 2000 bootstrap resamples are used to estimate uncertainty in the doubling time and trendline. The 95% CI represents the 2.5th and 97.5th percentiles of the bootstrap distribution.</p>
                <p style="margin-top: 0.75rem;"><strong>Prediction Intervals:</strong> The shaded projection region combines trend uncertainty (from bootstrap) with residual variance, giving proper prediction intervals for future observations.</p>
                <p style="margin-top: 0.75rem;"><strong>Model Comparison:</strong> Exponential and linear models are compared using AIC (Akaike Information Criterion). Lower AIC indicates better fit accounting for model complexity.</p>
                <p style="margin-top: 0.75rem;"><strong>Out-of-Sample Validation:</strong> The model is re-fit excluding the most recent 3 models, then tested on how well it predicts those held-out observations.</p>
            </div>
        </div>

        <div class="calculator-section">
            <details>
                <summary style="cursor: pointer; font-weight: 600; color: #0f172a;">Raw Data</summary>
                <div style="margin-top: 1rem; overflow-x: auto;">
                    <table id="rawDataTable" style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
                        <thead>
                            <tr style="border-bottom: 2px solid #e2e8f0;">
                                <th style="text-align: left; padding: 0.5rem; color: #64748b;">Model</th>
                                <th style="text-align: left; padding: 0.5rem; color: #64748b;">Family</th>
                                <th style="text-align: left; padding: 0.5rem; color: #64748b;">Release Date</th>
                                <th style="text-align: right; padding: 0.5rem; color: #64748b;">Time Horizon</th>
                                <th style="text-align: right; padding: 0.5rem; color: #64748b;">95% CI</th>
                            </tr>
                        </thead>
                        <tbody id="rawDataBody">
                        </tbody>
                    </table>
                </div>
            </details>
        </div>

        <footer>
            <div style="margin-bottom: 0.75rem;">
                Based on <a href="https://metr.org/blog/2025-03-19-measuring-ai-ability-to-complete-long-tasks/" target="_blank">"Measuring AI Ability to Complete Long Tasks"</a> by METR
                ¬∑ <a href="https://metr.org/notes/2026-01-22-time-horizon-limitations/" target="_blank">Limitations</a>
                ¬∑ <a href="https://metr.org/assets/benchmark_results.yaml" target="_blank">Raw Data</a>
            </div>
            <details style="display: inline-block; text-align: left;">
                <summary style="cursor: pointer;">Citation</summary>
                <pre style="background: #f1f5f9; padding: 1rem; border-radius: 6px; font-size: 0.75rem; overflow-x: auto; text-align: left; margin-top: 0.5rem;">@article{metr2025horizon,
  title={Measuring AI Ability to Complete Long Tasks},
  author={METR},
  journal={arXiv preprint arXiv:2503.14499},
  year={2025}
}</pre>
            </details>
        </footer>
    </div>

    <script>
    // ============================================
    // STATISTICAL FUNCTIONS
    // ============================================

    /**
     * Weighted linear regression
     * @param {number[]} x - Independent variable
     * @param {number[]} y - Dependent variable
     * @param {number[]} weights - Weights for each observation
     * @returns {Object} - {slope, intercept, rSquared, residuals, yHat}
     */
    function weightedLinearRegression(x, y, weights = null) {
        const n = x.length;
        if (!weights) {
            weights = new Array(n).fill(1);
        }

        const sumW = weights.reduce((a, b) => a + b, 0);
        const sumWX = x.reduce((sum, xi, i) => sum + weights[i] * xi, 0);
        const sumWY = y.reduce((sum, yi, i) => sum + weights[i] * yi, 0);
        const sumWXY = x.reduce((sum, xi, i) => sum + weights[i] * xi * y[i], 0);
        const sumWX2 = x.reduce((sum, xi, i) => sum + weights[i] * xi * xi, 0);

        const meanX = sumWX / sumW;
        const meanY = sumWY / sumW;

        const slope = (sumWXY - sumW * meanX * meanY) / (sumWX2 - sumW * meanX * meanX);
        const intercept = meanY - slope * meanX;

        // Calculate R-squared
        const yHat = x.map(xi => slope * xi + intercept);
        const ssRes = y.reduce((sum, yi, i) => sum + weights[i] * Math.pow(yi - yHat[i], 2), 0);
        const ssTot = y.reduce((sum, yi, i) => sum + weights[i] * Math.pow(yi - meanY, 2), 0);
        const rSquared = 1 - ssRes / ssTot;

        const residuals = y.map((yi, i) => yi - yHat[i]);
        const rmse = Math.sqrt(ssRes / sumW);

        return { slope, intercept, rSquared, residuals, yHat, rmse };
    }

    /**
     * Calculate AIC for model comparison
     */
    function calculateAIC(n, rss, k) {
        // AIC = n * ln(RSS/n) + 2k
        return n * Math.log(rss / n) + 2 * k;
    }

    /**
     * Bootstrap resampling for confidence intervals
     * @param {Object[]} data - Array of data points
     * @param {Function} statFn - Function that computes statistic from data
     * @param {number} nBootstrap - Number of bootstrap samples
     * @returns {Object} - {estimate, ci95, distribution}
     */
    function bootstrap(data, statFn, nBootstrap = 2000) {
        const n = data.length;
        const bootstrapStats = [];

        for (let b = 0; b < nBootstrap; b++) {
            // Resample with replacement
            const sample = [];
            for (let i = 0; i < n; i++) {
                const idx = Math.floor(Math.random() * n);
                sample.push(data[idx]);
            }

            try {
                const stat = statFn(sample);
                if (isFinite(stat)) {
                    bootstrapStats.push(stat);
                }
            } catch (e) {
                // Skip failed iterations
            }
        }

        bootstrapStats.sort((a, b) => a - b);

        const estimate = statFn(data);
        const lowIdx = Math.min(Math.floor(bootstrapStats.length * 0.025), bootstrapStats.length - 1);
        const highIdx = Math.min(Math.floor(bootstrapStats.length * 0.975), bootstrapStats.length - 1);
        const ci95Low = bootstrapStats[lowIdx];
        const ci95High = bootstrapStats[highIdx];

        return {
            estimate,
            ci95: [ci95Low, ci95High],
            distribution: bootstrapStats
        };
    }

    /**
     * Compute doubling time from data
     */
    function computeDoublingTime(data) {
        const x = data.map(d => d.dateNum);
        const y = data.map(d => Math.log(d.horizon));
        const weights = data.map(d => d.weight);

        const reg = weightedLinearRegression(x, y, weights);
        const doublingTime = Math.log(2) / reg.slope;

        return doublingTime;
    }

    /**
     * Full regression analysis with bootstrap
     */
    function analyzeData(data, nBootstrap = 2000) {
        // Prepare data
        const x = data.map(d => d.dateNum);
        const y = data.map(d => Math.log(d.horizon));
        const weights = data.map(d => d.weight);

        // Fit weighted regression
        const expReg = weightedLinearRegression(x, y, weights);
        const doublingTime = Math.log(2) / expReg.slope;

        // Also fit linear model for comparison
        const yLinear = data.map(d => d.horizon);
        const linearReg = weightedLinearRegression(x, yLinear, weights);

        // Calculate AIC for model comparison
        const n = data.length;
        const rssExp = expReg.residuals.reduce((sum, r, i) => sum + weights[i] * r * r, 0);
        const rssLinear = linearReg.residuals.reduce((sum, r, i) => sum + weights[i] * r * r, 0);
        const aicExp = calculateAIC(n, rssExp, 2);
        const aicLinear = calculateAIC(n, rssLinear, 2);

        // Bootstrap for doubling time CI
        const bootstrapResult = bootstrap(data, computeDoublingTime, nBootstrap);

        // Bootstrap for trendline uncertainty
        const trendlineBootstrap = [];
        for (let b = 0; b < Math.min(500, nBootstrap); b++) {
            const sample = [];
            for (let i = 0; i < n; i++) {
                const idx = Math.floor(Math.random() * n);
                sample.push(data[idx]);
            }
            const bx = sample.map(d => d.dateNum);
            const by = sample.map(d => Math.log(d.horizon));
            const bw = sample.map(d => d.weight);
            const bReg = weightedLinearRegression(bx, by, bw);
            trendlineBootstrap.push(bReg);
        }

        return {
            regression: expReg,
            linearRegression: linearReg,
            doublingTime: {
                estimate: doublingTime,
                ci95: bootstrapResult.ci95,
                distribution: bootstrapResult.distribution
            },
            modelComparison: {
                exponentialAIC: aicExp,
                linearAIC: aicLinear,
                preferExponential: aicExp < aicLinear
            },
            trendlineBootstrap,
            residualStd: expReg.rmse
        };
    }

    /**
     * Out-of-sample validation
     */
    function outOfSampleTest(data, nHoldout = 3) {
        if (data.length <= nHoldout + 3) {
            return null;
        }

        // Sort by date
        const sorted = [...data].sort((a, b) => a.dateNum - b.dateNum);
        const trainData = sorted.slice(0, -nHoldout);
        const testData = sorted.slice(-nHoldout);

        // Fit on training data
        const x = trainData.map(d => d.dateNum);
        const y = trainData.map(d => Math.log(d.horizon));
        const weights = trainData.map(d => d.weight);
        const reg = weightedLinearRegression(x, y, weights);

        // Predict on test data
        const predictions = testData.map(d => ({
            actual: d.horizon,
            predicted: Math.exp(reg.slope * d.dateNum + reg.intercept),
            model: d.name
        }));

        // Calculate MAPE (Mean Absolute Percentage Error)
        const mape = predictions.reduce((sum, p) =>
            sum + Math.abs(p.actual - p.predicted) / p.actual, 0) / predictions.length;

        // Check if actuals fall within prediction interval
        const residualStd = reg.rmse;
        const withinInterval = predictions.filter(p => {
            const logPred = Math.log(p.predicted);
            const logActual = Math.log(p.actual);
            return Math.abs(logActual - logPred) < 1.96 * residualStd;
        }).length;

        return {
            mape,
            coverage: withinInterval / predictions.length,
            predictions
        };
    }

    // ============================================
    // DATA PROCESSING
    // ============================================

    // ============================================
    // MODEL CLASSIFICATION
    // ============================================

    // Family-based classification for country/region
    const FAMILY_COUNTRY_MAP = {
        "Anthropic": "US",
        "OpenAI": "US",
        "Google": "US",
        "xAI": "US",
        "Meta": "US",
        "Mistral": "EU",
        "DeepSeek": "China",
        "Alibaba": "China",
        "Moonshot": "China",
        "Baichuan": "China",
    };

    // Families that typically release open-weight models
    const OPEN_WEIGHT_FAMILIES = new Set([
        "DeepSeek", "Alibaba", "Meta", "Mistral", "Baichuan"
    ]);

    // Patterns in model_id that indicate open weights
    const OPEN_WEIGHT_PATTERNS = ["oss", "open", "llama", "mistral"];

    // Specific model overrides
    const MODEL_OVERRIDES = {
        "gpt2": { isOpen: true },
        "kimi_k2_thinking": { isOpen: true },
    };

    function isOpenModel(modelId, family) {
        const id = modelId.toLowerCase();

        // Check overrides first
        if (MODEL_OVERRIDES[modelId]?.isOpen !== undefined) {
            return MODEL_OVERRIDES[modelId].isOpen;
        }

        // Check family
        if (OPEN_WEIGHT_FAMILIES.has(family)) {
            return true;
        }

        // Check patterns
        for (const pattern of OPEN_WEIGHT_PATTERNS) {
            if (id.includes(pattern)) return true;
        }

        return false;
    }

    function getModelCountry(modelId, family) {
        if (MODEL_OVERRIDES[modelId]?.country) {
            return MODEL_OVERRIDES[modelId].country;
        }
        return FAMILY_COUNTRY_MAP[family] || "Other";
    }

    const MODEL_NAMES = {
        "claude_3_5_sonnet": "Claude 3.5 Sonnet",
        "claude_3_5_sonnet_20241022": "Claude 3.5 Sonnet (Oct 2024)",
        "claude_3_7_sonnet": "Claude 3.7 Sonnet",
        "claude_3_opus": "Claude 3 Opus",
        "claude_4_opus": "Claude 4 Opus",
        "claude_4_1_opus": "Claude 4.1 Opus",
        "claude_4_sonnet": "Claude 4 Sonnet",
        "claude_sonnet_4_5": "Claude Sonnet 4.5",
        "claude_opus_4_5": "Claude Opus 4.5",
        "gpt2": "GPT-2",
        "gpt_3_5_turbo_instruct": "GPT-3.5 Turbo Instruct",
        "gpt_4": "GPT-4",
        "gpt_4_0125": "GPT-4 (Jan 2024)",
        "gpt_4_1106": "GPT-4 Turbo (Nov 2023)",
        "gpt_4_turbo": "GPT-4 Turbo",
        "gpt_4o": "GPT-4o",
        "gpt_5": "GPT-5",
        "gpt_5_1_codex_max": "GPT-5.1 Codex Max",
        "gpt-oss-120b": "GPT-OSS-120B",
        "o1_preview": "o1 Preview",
        "o1_elicited": "o1 (Elicited)",
        "o3": "o3",
        "o4-mini": "o4-mini",
        "davinci_002": "Davinci-002",
        "deepseek_r1": "DeepSeek R1",
        "deepseek_r1_0528": "DeepSeek R1 (May 2025)",
        "deepseek_v3": "DeepSeek V3",
        "deepseek_v3_0324": "DeepSeek V3 (Mar 2025)",
        "gemini_2_5_pro_preview": "Gemini 2.5 Pro Preview",
        "grok_4": "Grok 4",
        "kimi_k2_thinking": "Kimi K2 Thinking",
        "qwen_2_5_72b": "Qwen 2.5 72B",
        "qwen_2_72b": "Qwen 2 72B",
    };

    const FAMILY_COLORS = {
        "Anthropic": "#d97757",
        "OpenAI": "#18a683",
        "DeepSeek": "#5B8FF9",
        "Google": "#F6BD16",
        "Alibaba": "#E8684A",
        "xAI": "#9C5EDA",
        "Moonshot": "#FF9D4D",
        "Other": "#999999",
    };

    function getModelFamily(modelId) {
        const id = modelId.toLowerCase();
        if (id.includes("claude")) return "Anthropic";
        if (id.includes("gpt") || id.includes("davinci") || id.startsWith("o1") || id.startsWith("o3") || id.startsWith("o4")) return "OpenAI";
        if (id.includes("deepseek")) return "DeepSeek";
        if (id.includes("gemini")) return "Google";
        if (id.includes("qwen")) return "Alibaba";
        if (id.includes("grok")) return "xAI";
        if (id.includes("kimi")) return "Moonshot";
        if (id.includes("llama")) return "Meta";
        if (id.includes("mistral") || id.includes("mixtral")) return "Mistral";
        return "Other";
    }

    function parseYAMLData(yamlData, horizonType) {
        const results = yamlData.results;
        const data = [];

        for (const [modelId, modelData] of Object.entries(results)) {
            const metrics = modelData.metrics;
            const horizon = metrics[`${horizonType}_horizon_length`];

            if (!horizon || !horizon.estimate || !modelData.release_date) continue;

            const date = new Date(modelData.release_date);
            const name = MODEL_NAMES[modelId] || modelId.replace(/_/g, ' ');

            // Convert minutes to hours
            const estimate = horizon.estimate / 60;
            const ciLow = (horizon.ci_low || horizon.estimate * 0.5) / 60;
            const ciHigh = (horizon.ci_high || horizon.estimate * 2) / 60;

            // Weight by inverse variance (from CI)
            const logCIWidth = Math.log(ciHigh) - Math.log(ciLow);
            const variance = Math.pow(logCIWidth / (2 * 1.96), 2);
            const weight = 1 / Math.max(variance, 0.01);

            const family = getModelFamily(modelId);
            const isOpen = isOpenModel(modelId, family);
            const country = getModelCountry(modelId, family);

            data.push({
                id: modelId,
                name,
                family,
                date,
                dateNum: date.getTime() / (1000 * 60 * 60 * 24), // Days since epoch
                horizon: estimate,
                ciLow,
                ciHigh,
                weight,
                avgScore: metrics.average_score?.estimate,
                isSota: metrics.is_sota,
                isOpen,
                country,
                isChina: country === "China",
                isUS: country === "US"
            });
        }

        return data.sort((a, b) => a.date - b.date);
    }

    function formatHours(hours) {
        if (hours < 1/60) return `${(hours * 3600).toFixed(1)} sec`;
        if (hours < 1) return `${(hours * 60).toFixed(1)} min`;
        if (hours < 24) return `${hours.toFixed(1)} hrs`;
        return `${(hours / 24).toFixed(1)} days`;
    }

    function formatDate(date) {
        return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
    }

    // ============================================
    // GAP CALCULATION FUNCTIONS
    // ============================================

    const DAYS_PER_MONTH = 30.5;

    /**
     * Get frontier models for a group (cumulative max horizon over time)
     */
    function getFrontierModels(data, groupFn) {
        const groups = {};
        data.forEach(d => {
            const group = groupFn(d);
            if (!groups[group]) groups[group] = [];
            groups[group].push(d);
        });

        const frontierModels = [];
        for (const [group, models] of Object.entries(groups)) {
            const sorted = [...models].sort((a, b) => a.date - b.date);
            let maxHorizon = 0;
            for (const model of sorted) {
                if (model.horizon >= maxHorizon) {
                    maxHorizon = model.horizon;
                    frontierModels.push(model);
                }
            }
        }

        return frontierModels.sort((a, b) => a.date - b.date);
    }

    /**
     * Calculate horizontal gaps between leading and lagging groups
     */
    function calculateHorizontalGaps(data, groupKey, leadingValue) {
        const leadingData = data.filter(d => d[groupKey] === leadingValue);
        const laggingData = data.filter(d => d[groupKey] !== leadingValue);

        const leadingFrontier = getFrontierModels(leadingData, d => d.family);
        const laggingFrontier = getFrontierModels(laggingData, d => d.family);

        const gaps = [];

        for (const leading of leadingFrontier) {
            // Find first lagging model released AFTER leading that matches horizon
            let matchingLagging = null;
            for (const lagging of laggingFrontier) {
                if (lagging.date <= leading.date) continue;
                if (lagging.horizon >= leading.horizon) {
                    matchingLagging = lagging;
                    break;
                }
            }

            if (matchingLagging) {
                const gapDays = (matchingLagging.date - leading.date) / (1000 * 60 * 60 * 24);
                gaps.push({
                    leadingModel: leading.name,
                    leadingDate: leading.date,
                    leadingHorizon: leading.horizon,
                    laggingModel: matchingLagging.name,
                    laggingDate: matchingLagging.date,
                    laggingHorizon: matchingLagging.horizon,
                    gapMonths: gapDays / DAYS_PER_MONTH,
                    matched: true
                });
            } else {
                const gapDays = (new Date() - leading.date) / (1000 * 60 * 60 * 24);
                gaps.push({
                    leadingModel: leading.name,
                    leadingDate: leading.date,
                    leadingHorizon: leading.horizon,
                    laggingModel: null,
                    laggingDate: null,
                    laggingHorizon: null,
                    gapMonths: gapDays / DAYS_PER_MONTH,
                    matched: false
                });
            }
        }

        return gaps;
    }

    /**
     * Calculate gap statistics
     */
    function calculateGapStatistics(gaps) {
        const matchedGaps = gaps.filter(g => g.matched).map(g => g.gapMonths);

        if (matchedGaps.length === 0) {
            return {
                avgGapMonths: null,
                stdGapMonths: null,
                minGapMonths: null,
                maxGapMonths: null,
                totalMatched: 0,
                totalUnmatched: gaps.filter(g => !g.matched).length
            };
        }

        const avg = matchedGaps.reduce((a, b) => a + b, 0) / matchedGaps.length;
        const variance = matchedGaps.reduce((sum, g) => sum + Math.pow(g - avg, 2), 0) / matchedGaps.length;
        const std = Math.sqrt(variance);

        return {
            avgGapMonths: avg,
            stdGapMonths: std,
            minGapMonths: Math.min(...matchedGaps),
            maxGapMonths: Math.max(...matchedGaps),
            totalMatched: matchedGaps.length,
            totalUnmatched: gaps.filter(g => !g.matched).length
        };
    }

    /**
     * Calculate trend statistics for a group
     */
    function calculateGroupTrend(data) {
        if (data.length < 2) return null;

        const frontier = getFrontierModels(data, d => d.family);
        if (frontier.length < 2) return null;

        const x = frontier.map(d => d.dateNum);
        const y = frontier.map(d => Math.log(d.horizon));
        // Use actual weights from data for consistency with main analysis
        const weights = frontier.map(d => d.weight || 1);

        const reg = weightedLinearRegression(x, y, weights);
        const doublingTimeDays = Math.log(2) / reg.slope;

        return {
            doublingTimeDays,
            doublingTimeMonths: doublingTimeDays / DAYS_PER_MONTH,
            rSquared: reg.rSquared,
            slope: reg.slope,
            intercept: reg.intercept,
            nModels: frontier.length,
            startDate: frontier[0].date,
            endDate: frontier[frontier.length - 1].date
        };
    }

    /**
     * Calculate current vertical gap between groups
     */
    function calculateVerticalGap(data, groupKey, leadingValue) {
        const leadingData = data.filter(d => d[groupKey] === leadingValue);
        const laggingData = data.filter(d => d[groupKey] !== leadingValue);

        if (leadingData.length === 0 || laggingData.length === 0) {
            return { gapHours: null, gapRatio: null };
        }

        const bestLeading = Math.max(...leadingData.map(d => d.horizon));
        const bestLagging = Math.max(...laggingData.map(d => d.horizon));

        return {
            bestLeadingHorizon: bestLeading,
            bestLaggingHorizon: bestLagging,
            gapHours: bestLeading - bestLagging,
            gapRatio: bestLagging > 0 ? bestLeading / bestLagging : null
        };
    }

    /**
     * Standard normal CDF approximation
     */
    function normalCDF(x) {
        const a1 =  0.254829592;
        const a2 = -0.284496736;
        const a3 =  1.421413741;
        const a4 = -1.453152027;
        const a5 =  1.061405429;
        const p  =  0.3275911;

        const sign = x < 0 ? -1 : 1;
        x = Math.abs(x) / Math.sqrt(2);

        const t = 1.0 / (1.0 + p * x);
        const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);

        return 0.5 * (1.0 + sign * y);
    }

    /**
     * Estimate current gap using survival analysis with censored observations.
     *
     * Uses Bayesian approach:
     * 1. Fit log-normal distribution to historical matched gaps
     * 2. For unmatched models, calculate E[X | X > c] (truncated expectation)
     * 3. Weight by age (older unmatched models are more informative)
     */
    function estimateCurrentGap(gaps) {
        const matched = gaps.filter(g => g.matched);
        const unmatched = gaps.filter(g => !g.matched);

        const matchedGapMonths = matched.map(g => g.gapMonths).filter(g => g > 0);
        const unmatchedAges = unmatched.map(g => g.gapMonths).sort((a, b) => b - a);

        // No unmatched models - current gap is 0
        if (unmatched.length === 0) {
            return {
                estimatedCurrentGap: 0,
                minCurrentGap: 0,
                confidence: 'high',
                method: 'no_unmatched',
                unmatchedAges: [],
                priorParams: null
            };
        }

        const minCurrentGap = Math.max(...unmatchedAges);

        // Not enough matched data for proper estimation
        if (matchedGapMonths.length < 3) {
            const estimated = minCurrentGap * 1.3; // Heuristic: add 30%
            return {
                estimatedCurrentGap: estimated,
                minCurrentGap: minCurrentGap,
                confidence: 'low',
                method: 'insufficient_data_heuristic',
                unmatchedAges: unmatchedAges,
                priorParams: null
            };
        }

        // Fit log-normal distribution to matched gaps
        const logMatched = matchedGapMonths.map(g => Math.log(g));
        const muPrior = logMatched.reduce((a, b) => a + b, 0) / logMatched.length;
        let sigmaPrior = Math.sqrt(
            logMatched.reduce((sum, x) => sum + Math.pow(x - muPrior, 2), 0) / logMatched.length
        );
        if (sigmaPrior === 0) sigmaPrior = 0.5;

        /**
         * E[X | X > c] for log-normal distribution
         * Uses truncated log-normal formula
         */
        function expectedGivenGreaterThan(c, mu, sigma) {
            if (c <= 0) {
                return Math.exp(mu + sigma * sigma / 2);
            }

            const logC = Math.log(c);
            const z = (logC - mu) / sigma;
            const survival = 1 - normalCDF(z);

            if (survival < 1e-10) {
                // Survival very small - gap likely much larger
                return c * 2;
            }

            // E[X | X > c] = exp(mu + sigma^2/2) * Phi((mu + sigma^2 - ln(c))/sigma) / S(c)
            const zShifted = (mu + sigma * sigma - logC) / sigma;
            const expected = Math.exp(mu + sigma * sigma / 2) * normalCDF(zShifted) / survival;

            return expected;
        }

        // Calculate expected gap for each unmatched model
        const expectedGaps = [];
        for (const age of unmatchedAges) {
            if (age > 0) {
                const expGap = expectedGivenGreaterThan(age, muPrior, sigmaPrior);
                expectedGaps.push(expGap);
            }
        }

        let estimated, confidence;

        if (expectedGaps.length > 0) {
            // Weight by age (older unmatched models are more informative)
            const weights = unmatchedAges.slice(0, expectedGaps.length);
            const totalWeight = weights.reduce((a, b) => a + b, 0);
            const normalizedWeights = totalWeight > 0
                ? weights.map(w => w / totalWeight)
                : weights.map(() => 1 / weights.length);

            // Weighted average of expected gaps
            estimated = expectedGaps.reduce((sum, g, i) => sum + g * normalizedWeights[i], 0);
            estimated = Math.max(estimated, minCurrentGap);

            // Calculate confidence based on deviation from prior mean
            const priorMean = Math.exp(muPrior + sigmaPrior * sigmaPrior / 2);
            const deviationRatio = priorMean > 0 ? minCurrentGap / priorMean : 2;

            if (deviationRatio < 1.5) {
                confidence = 'high';
            } else if (deviationRatio < 2.5) {
                confidence = 'medium';
            } else {
                confidence = 'low';
            }
        } else {
            estimated = minCurrentGap * 1.3;
            confidence = 'low';
        }

        return {
            estimatedCurrentGap: estimated,
            minCurrentGap: minCurrentGap,
            confidence: confidence,
            method: 'survival_analysis_mle',
            unmatchedAges: unmatchedAges,
            priorParams: {
                mu: muPrior,
                sigma: sigmaPrior,
                priorMeanMonths: Math.exp(muPrior + sigmaPrior * sigmaPrior / 2)
            }
        };
    }

    // ============================================
    // PLOTTING
    // ============================================

    function createPlot(data, analysis, options) {
        const {
            showCI,
            showProjection,
            showBootstrap,
            endYear,
            customScenarios
        } = options;

        const traces = [];

        // Group data by family for coloring
        const families = [...new Set(data.map(d => d.family))];

        for (const family of families) {
            const familyData = data.filter(d => d.family === family);
            const color = FAMILY_COLORS[family] || "#999";

            // Error bars
            if (showCI) {
                traces.push({
                    x: familyData.map(d => d.date),
                    y: familyData.map(d => d.horizon),
                    error_y: {
                        type: 'data',
                        symmetric: false,
                        array: familyData.map(d => d.ciHigh - d.horizon),
                        arrayminus: familyData.map(d => d.horizon - d.ciLow),
                        color: color,
                        thickness: 1.5,
                        width: 4
                    },
                    mode: 'markers',
                    type: 'scatter',
                    name: family,
                    marker: {
                        color: color,
                        size: 10,
                        line: { color: 'white', width: 1 }
                    },
                    hovertemplate: familyData.map(d =>
                        `<b>${d.name}</b><br>` +
                        `Date: ${formatDate(d.date)}<br>` +
                        `Horizon: ${formatHours(d.horizon)}<br>` +
                        `95% CI: [${formatHours(d.ciLow)}, ${formatHours(d.ciHigh)}]<br>` +
                        `<extra></extra>`
                    )
                });
            } else {
                traces.push({
                    x: familyData.map(d => d.date),
                    y: familyData.map(d => d.horizon),
                    mode: 'markers',
                    type: 'scatter',
                    name: family,
                    marker: {
                        color: color,
                        size: 10,
                        line: { color: 'white', width: 1 }
                    },
                    hovertemplate: familyData.map(d =>
                        `<b>${d.name}</b><br>` +
                        `Date: ${formatDate(d.date)}<br>` +
                        `Horizon: ${formatHours(d.horizon)}<br>` +
                        `<extra></extra>`
                    )
                });
            }
        }

        // Fitted trendline
        const minDate = Math.min(...data.map(d => d.dateNum));
        const maxDate = Math.max(...data.map(d => d.dateNum));
        const endDate = new Date(endYear, 11, 31).getTime() / (1000 * 60 * 60 * 24);

        const trendX = [];
        const trendY = [];
        for (let d = minDate; d <= maxDate; d += 7) {
            trendX.push(new Date(d * 24 * 60 * 60 * 1000));
            trendY.push(Math.exp(analysis.regression.slope * d + analysis.regression.intercept));
        }

        const dt = analysis.doublingTime.estimate;
        const dtMonths = dt / 30.44;

        traces.push({
            x: trendX,
            y: trendY,
            mode: 'lines',
            type: 'scatter',
            name: `Fitted Trend (${dt.toFixed(0)}d doubling)`,
            line: { color: '#2563eb', width: 2.5 },
            hovertemplate: trendX.map((date, i) =>
                `Date: ${formatDate(date)}<br>` +
                `Horizon: ${formatHours(trendY[i])}<br>` +
                `Doubling: ${dt.toFixed(0)} days (${dtMonths.toFixed(1)} months)<br>` +
                `<extra></extra>`
            )
        });

        // Projection with bootstrap uncertainty
        if (showProjection && maxDate < endDate) {
            const projX = [];
            const projY = [];
            const projUpper = [];
            const projLower = [];

            for (let d = maxDate; d <= endDate; d += 7) {
                const date = new Date(d * 24 * 60 * 60 * 1000);
                projX.push(date);

                const pred = Math.exp(analysis.regression.slope * d + analysis.regression.intercept);
                projY.push(pred);

                if (showBootstrap && analysis.trendlineBootstrap.length > 0) {
                    // Get prediction interval from bootstrap
                    const bootstrapPreds = analysis.trendlineBootstrap.map(reg =>
                        Math.exp(reg.slope * d + reg.intercept)
                    );
                    bootstrapPreds.sort((a, b) => a - b);

                    // Add residual variance for prediction interval
                    const trendLow = bootstrapPreds[Math.floor(bootstrapPreds.length * 0.025)];
                    const trendHigh = bootstrapPreds[Math.floor(bootstrapPreds.length * 0.975)];

                    // Expand by residual std for prediction interval
                    const residualFactor = Math.exp(1.96 * analysis.residualStd);
                    projLower.push(trendLow / residualFactor);
                    projUpper.push(trendHigh * residualFactor);
                } else {
                    // Simple expanding uncertainty
                    const daysAhead = d - maxDate;
                    const factor = 1 + 0.001 * daysAhead;
                    projLower.push(pred / Math.pow(factor, 2));
                    projUpper.push(pred * Math.pow(factor, 2));
                }
            }

            // Prediction interval band
            traces.push({
                x: projX.concat([...projX].reverse()),
                y: projUpper.concat([...projLower].reverse()),
                fill: 'toself',
                fillcolor: 'rgba(37, 99, 235, 0.15)',
                line: { color: 'transparent' },
                type: 'scatter',
                name: '95% Prediction Interval',
                showlegend: true,
                hoverinfo: 'skip'
            });

            // Projection line
            traces.push({
                x: projX,
                y: projY,
                mode: 'lines',
                type: 'scatter',
                name: 'Projection',
                line: { color: '#2563eb', width: 2, dash: 'dash' },
                opacity: 0.7,
                hovertemplate: projX.map((date, i) =>
                    `Date: ${formatDate(date)}<br>` +
                    `Projected: ${formatHours(projY[i])}<br>` +
                    `95% PI: [${formatHours(projLower[i])}, ${formatHours(projUpper[i])}]<br>` +
                    `<extra></extra>`
                )
            });
        }

        // Custom scenario projections
        const customColors = ['#e11d48', '#7c3aed', '#059669'];
        customScenarios.forEach((scenarioDays, i) => {
            if (scenarioDays > 0) {
                const projX = [];
                const projY = [];

                const startValue = Math.exp(analysis.regression.slope * maxDate + analysis.regression.intercept);

                for (let d = maxDate; d <= endDate; d += 7) {
                    const date = new Date(d * 24 * 60 * 60 * 1000);
                    projX.push(date);

                    const daysElapsed = d - maxDate;
                    const value = startValue * Math.pow(2, daysElapsed / scenarioDays);
                    projY.push(value);
                }

                const months = scenarioDays / 30.44;
                traces.push({
                    x: projX,
                    y: projY,
                    mode: 'lines',
                    type: 'scatter',
                    name: `Custom: ${scenarioDays}d (${months.toFixed(1)}mo)`,
                    line: { color: customColors[i], width: 2, dash: 'dot' },
                    hovertemplate: projX.map((date, j) =>
                        `Date: ${formatDate(date)}<br>` +
                        `Horizon: ${formatHours(projY[j])}<br>` +
                        `Doubling: ${scenarioDays} days<br>` +
                        `<extra></extra>`
                    )
                });
            }
        });

        // Today line
        const today = new Date();
        traces.push({
            x: [today, today],
            y: [0.0001, 10000],
            mode: 'lines',
            type: 'scatter',
            name: 'Today',
            line: { color: 'rgba(255, 0, 255, 0.4)', width: 2, dash: 'dot' },
            showlegend: false,
            hoverinfo: 'skip'
        });

        const layout = {
            title: {
                text: 'AI Agent Time Horizons Over Time',
                font: { size: 18 }
            },
            xaxis: {
                title: 'Model Release Date',
                gridcolor: 'rgba(128,128,128,0.2)',
                range: [new Date(2019, 0, 1), new Date(endYear, 11, 31)]
            },
            yaxis: {
                title: 'Time Horizon (human expert time)',
                type: 'log',
                gridcolor: 'rgba(128,128,128,0.2)',
                tickvals: [1/3600, 1/60, 1/6, 0.5, 1, 2, 4, 8, 24, 48, 168, 720],
                ticktext: ['1s', '1m', '10m', '30m', '1h', '2h', '4h', '8h', '1d', '2d', '1w', '1mo']
            },
            legend: {
                orientation: 'v',
                x: 1.02,
                y: 1
            },
            hovermode: 'closest',
            plot_bgcolor: 'white',
            paper_bgcolor: 'white',
            margin: { r: 150, t: 60 },
            height: 550
        };

        Plotly.newPlot('plot', traces, layout, { responsive: true });
    }

    // ============================================
    // UI UPDATES
    // ============================================

    function updateStats(analysis, data, oosResult) {
        const dt = analysis.doublingTime;
        document.getElementById('doublingTime').textContent = `${dt.estimate.toFixed(0)} days`;
        document.getElementById('doublingTimeCI').textContent =
            `95% CI: [${dt.ci95[0].toFixed(0)}, ${dt.ci95[1].toFixed(0)}] days`;
        document.getElementById('doublingTimeDetail').textContent =
            `${(dt.estimate / 30.44).toFixed(1)} months (${(dt.ci95[0]/30.44).toFixed(1)}‚Äì${(dt.ci95[1]/30.44).toFixed(1)})`;

        const r2 = analysis.regression.rSquared;
        document.getElementById('rSquared').textContent = `R¬≤ = ${r2.toFixed(3)}`;

        const expAIC = analysis.modelComparison.exponentialAIC;
        const linAIC = analysis.modelComparison.linearAIC;
        const aicDiff = linAIC - expAIC;
        document.getElementById('modelComparison').innerHTML =
            analysis.modelComparison.preferExponential
                ? `<span class="model-comparison">Exponential preferred</span> (ŒîAIC = ${aicDiff.toFixed(1)})`
                : `Linear may fit better (ŒîAIC = ${aicDiff.toFixed(1)})`;
        document.getElementById('fitDetail').textContent =
            `Exp AIC: ${expAIC.toFixed(1)} | Linear AIC: ${linAIC.toFixed(1)}`;

        const latest = data[data.length - 1];
        document.getElementById('currentHorizon').textContent = formatHours(latest.horizon);
        document.getElementById('currentModel').textContent = latest.name;
        document.getElementById('currentDetail').textContent = `Released ${formatDate(latest.date)}`;

        if (oosResult) {
            document.getElementById('oosTest').textContent = `${(oosResult.coverage * 100).toFixed(0)}% coverage`;
            document.getElementById('oosDetail').textContent =
                `MAPE: ${(oosResult.mape * 100).toFixed(1)}% | ${oosResult.predictions.length} models tested`;
        } else {
            document.getElementById('oosTest').textContent = 'N/A';
            document.getElementById('oosDetail').textContent = 'Not enough data';
        }
    }

    function updateModelSelectors(data) {
        const model1 = document.getElementById('model1');
        const model2 = document.getElementById('model2');

        // Sort by date descending (newest first)
        const sorted = [...data].sort((a, b) => b.date - a.date);

        model1.innerHTML = sorted.map(d =>
            `<option value="${d.id}">${d.name} (${formatDate(d.date)})</option>`
        ).join('');

        model2.innerHTML = sorted.map(d =>
            `<option value="${d.id}">${d.name} (${formatDate(d.date)})</option>`
        ).join('');

        // Default: oldest for model1, newest for model2
        model1.selectedIndex = sorted.length - 1;
        model2.selectedIndex = 0;

        // Set date inputs
        const dates = data.map(d => d.date);
        const minDate = new Date(Math.min(...dates));
        const maxDate = new Date(Math.max(...dates));

        document.getElementById('calcStartDate').value = minDate.toISOString().split('T')[0];
        document.getElementById('calcEndDate').value = maxDate.toISOString().split('T')[0];
    }

    function updateModelCalc(data, horizonType) {
        const model1Id = document.getElementById('model1').value;
        const model2Id = document.getElementById('model2').value;

        const m1 = data.find(d => d.id === model1Id);
        const m2 = data.find(d => d.id === model2Id);

        const resultDiv = document.getElementById('modelCalcResult');

        if (!m1 || !m2 || m1.id === m2.id) {
            resultDiv.style.display = 'none';
            return;
        }

        // Ensure m1 is earlier
        const [earlier, later] = m1.date < m2.date ? [m1, m2] : [m2, m1];

        const daysBetween = (later.date - earlier.date) / (1000 * 60 * 60 * 24);

        if (later.horizon <= earlier.horizon) {
            resultDiv.className = 'calc-result warning';
            resultDiv.innerHTML = `<strong>No improvement detected</strong><br>
                ${later.name} (${formatHours(later.horizon)}) ‚â§ ${earlier.name} (${formatHours(earlier.horizon)})`;
            resultDiv.style.display = 'block';
            return;
        }

        const logRatio = Math.log2(later.horizon / earlier.horizon);
        const doublingTime = daysBetween / logRatio;
        const months = doublingTime / 30.44;

        resultDiv.className = 'calc-result';
        resultDiv.innerHTML = `
            <strong>Implied Doubling Time: ${doublingTime.toFixed(0)} days (${months.toFixed(1)} months)</strong><br>
            <span style="color: #64748b; font-size: 0.9rem;">
                ${earlier.name} ‚Üí ${later.name}<br>
                ${daysBetween.toFixed(0)} days elapsed |
                ${formatHours(earlier.horizon)} ‚Üí ${formatHours(later.horizon)} (${(later.horizon/earlier.horizon).toFixed(1)}x)
            </span>
        `;
        resultDiv.style.display = 'block';
    }

    function updateDateCalc(data) {
        const startDate = new Date(document.getElementById('calcStartDate').value);
        const endDate = new Date(document.getElementById('calcEndDate').value);

        const resultDiv = document.getElementById('dateCalcResult');

        if (startDate >= endDate) {
            resultDiv.style.display = 'none';
            return;
        }

        // Find models in range
        const modelsInRange = data.filter(d => d.date >= startDate && d.date <= endDate);

        if (modelsInRange.length < 2) {
            resultDiv.className = 'calc-result warning';
            resultDiv.innerHTML = '<strong>Not enough models in date range</strong>';
            resultDiv.style.display = 'block';
            return;
        }

        const sorted = modelsInRange.sort((a, b) => a.date - b.date);
        const first = sorted[0];
        const last = sorted[sorted.length - 1];

        // Use weighted linear regression over all points for more robust estimate
        const x = sorted.map(d => d.dateNum);
        const y = sorted.map(d => Math.log(d.horizon));
        const weights = sorted.map(d => d.weight || 1);

        const reg = weightedLinearRegression(x, y, weights);

        if (reg.slope <= 0) {
            resultDiv.className = 'calc-result warning';
            resultDiv.innerHTML = `<strong>No improvement in this period</strong>`;
            resultDiv.style.display = 'block';
            return;
        }

        const doublingTime = Math.log(2) / reg.slope;
        const months = doublingTime / 30.44;
        const daysBetween = (last.date - first.date) / (1000 * 60 * 60 * 24);

        resultDiv.className = 'calc-result';
        resultDiv.innerHTML = `
            <strong>Implied Doubling Time: ${doublingTime.toFixed(0)} days (${months.toFixed(1)} months)</strong><br>
            <span style="color: #64748b; font-size: 0.9rem;">
                Based on ${sorted.length} models over ${daysBetween.toFixed(0)} days (R¬≤ = ${reg.rSquared.toFixed(2)})<br>
                ${formatHours(first.horizon)} ‚Üí ${formatHours(last.horizon)} (${(last.horizon/first.horizon).toFixed(1)}x)
            </span>
        `;
        resultDiv.style.display = 'block';
    }

    function updateRawDataTable(data) {
        const tbody = document.getElementById('rawDataBody');

        // Sort by date descending (newest first)
        const sorted = [...data].sort((a, b) => b.date - a.date);

        tbody.innerHTML = sorted.map(d => {
            const color = FAMILY_COLORS[d.family] || '#999';
            return `
                <tr style="border-bottom: 1px solid #f1f5f9;">
                    <td style="padding: 0.5rem; font-weight: 500;">${d.name}</td>
                    <td style="padding: 0.5rem;">
                        <span style="display: inline-flex; align-items: center; gap: 0.4rem;">
                            <span style="width: 8px; height: 8px; border-radius: 50%; background: ${color};"></span>
                            ${d.family}
                        </span>
                    </td>
                    <td style="padding: 0.5rem;">${formatDate(d.date)}</td>
                    <td style="padding: 0.5rem; text-align: right; font-family: monospace;">${formatHours(d.horizon)}</td>
                    <td style="padding: 0.5rem; text-align: right; font-family: monospace; color: #64748b;">[${formatHours(d.ciLow)}, ${formatHours(d.ciHigh)}]</td>
                </tr>
            `;
        }).join('');
    }

    function updateMilestoneCalc(analysis, data) {
        const targetHours = parseFloat(document.getElementById('targetHorizon').value);
        const latest = data[data.length - 1];
        const currentHorizon = latest.horizon;

        const resultDiv = document.getElementById('milestoneResult');

        if (currentHorizon >= targetHours) {
            resultDiv.className = 'calc-result';
            resultDiv.innerHTML = `<strong>Already achieved!</strong> Current frontier: ${formatHours(currentHorizon)}`;
            resultDiv.style.display = 'block';
            return;
        }

        const dt = analysis.doublingTime;

        // Calculate for fitted doubling time
        const daysNeeded = dt.estimate * Math.log2(targetHours / currentHorizon);
        const targetDate = new Date(latest.date.getTime() + daysNeeded * 24 * 60 * 60 * 1000);

        // CI on target date
        const daysLow = dt.ci95[0] * Math.log2(targetHours / currentHorizon);
        const daysHigh = dt.ci95[1] * Math.log2(targetHours / currentHorizon);
        const dateLow = new Date(latest.date.getTime() + daysLow * 24 * 60 * 60 * 1000);
        const dateHigh = new Date(latest.date.getTime() + daysHigh * 24 * 60 * 60 * 1000);

        const daysFromNow = Math.round((targetDate - new Date()) / (1000 * 60 * 60 * 24));

        let html = `
            <strong>Fitted trend: ${targetDate.toLocaleDateString('en-US', {month: 'long', year: 'numeric'})}</strong><br>
            <span style="color: #64748b; font-size: 0.9rem;">
                95% CI: ${dateLow.toLocaleDateString('en-US', {month: 'short', year: 'numeric'})} ‚Äì
                ${dateHigh.toLocaleDateString('en-US', {month: 'short', year: 'numeric'})}
                ${daysFromNow > 0 ? `(~${daysFromNow} days from now)` : ''}
            </span>
        `;

        // Add custom scenarios
        const customInputs = [
            document.getElementById('custom1').value,
            document.getElementById('custom2').value,
            document.getElementById('custom3').value
        ];
        const colors = ['#e11d48', '#7c3aed', '#059669'];

        customInputs.forEach((val, i) => {
            const customDT = parseFloat(val);
            if (customDT > 0) {
                const customDays = customDT * Math.log2(targetHours / currentHorizon);
                const customDate = new Date(latest.date.getTime() + customDays * 24 * 60 * 60 * 1000);
                const customDaysFromNow = Math.round((customDate - new Date()) / (1000 * 60 * 60 * 24));
                const daysText = customDaysFromNow > 0 ? ` (~${customDaysFromNow} days from now)` : '';
                html += `<br><span style="color: ${colors[i]}; font-weight: 500;">
                    Custom ${customDT}d: ${customDate.toLocaleDateString('en-US', {month: 'long', year: 'numeric'})}${daysText}
                </span>`;
            }
        });

        resultDiv.className = 'calc-result';
        resultDiv.innerHTML = html;
        resultDiv.style.display = 'block';
    }

    // ============================================
    // GAP ANALYSIS UI
    // ============================================

    let currentGapFraming = 'open_closed';
    let currentGapMetric = 'average'; // 'average' or 'current'

    function createGapPlot(data, framing) {
        const isOpenClosed = framing === 'open_closed';
        const groupKey = isOpenClosed ? 'isOpen' : 'isChina';
        const leadingValue = false; // Closed or US models lead

        const leadingLabel = isOpenClosed ? 'Closed' : 'US';
        const laggingLabel = isOpenClosed ? 'Open' : 'China';
        const leadingColor = isOpenClosed ? '#e11d48' : '#2563eb';
        const laggingColor = isOpenClosed ? '#2563eb' : '#e11d48';

        const leadingData = data.filter(d => d[groupKey] === leadingValue);
        const laggingData = data.filter(d => d[groupKey] !== leadingValue);

        const leadingFrontier = getFrontierModels(leadingData, d => d.family);
        const laggingFrontier = getFrontierModels(laggingData, d => d.family);

        const traces = [];

        // Leading models
        if (leadingFrontier.length > 0) {
            traces.push({
                x: leadingFrontier.map(d => d.date),
                y: leadingFrontier.map(d => d.horizon),
                mode: 'markers+lines',
                type: 'scatter',
                name: `${leadingLabel} frontier`,
                marker: { color: leadingColor, size: 10, symbol: 'circle' },
                line: { color: leadingColor, width: 2 },
                hovertemplate: leadingFrontier.map(d =>
                    `<b>${d.name}</b><br>Date: ${formatDate(d.date)}<br>Horizon: ${formatHours(d.horizon)}<extra></extra>`
                )
            });
        }

        // Lagging models
        if (laggingFrontier.length > 0) {
            traces.push({
                x: laggingFrontier.map(d => d.date),
                y: laggingFrontier.map(d => d.horizon),
                mode: 'markers+lines',
                type: 'scatter',
                name: `${laggingLabel} frontier`,
                marker: { color: laggingColor, size: 10, symbol: 'square' },
                line: { color: laggingColor, width: 2 },
                hovertemplate: laggingFrontier.map(d =>
                    `<b>${d.name}</b><br>Date: ${formatDate(d.date)}<br>Horizon: ${formatHours(d.horizon)}<extra></extra>`
                )
            });
        }

        // Add trend lines
        const leadingTrend = calculateGroupTrend(leadingData);
        const laggingTrend = calculateGroupTrend(laggingData);

        if (leadingTrend && leadingTrend.doublingTimeDays > 0) {
            const trendX = [];
            const trendY = [];
            const startNum = leadingTrend.startDate.getTime() / (1000 * 60 * 60 * 24);
            const endNum = leadingTrend.endDate.getTime() / (1000 * 60 * 60 * 24);
            for (let d = startNum; d <= endNum; d += 7) {
                trendX.push(new Date(d * 24 * 60 * 60 * 1000));
                trendY.push(Math.exp(leadingTrend.slope * d + leadingTrend.intercept));
            }
            traces.push({
                x: trendX, y: trendY,
                mode: 'lines', type: 'scatter',
                name: `${leadingLabel} trend`,
                line: { color: leadingColor, width: 2, dash: 'dash' },
                opacity: 0.6,
                showlegend: false
            });
        }

        if (laggingTrend && laggingTrend.doublingTimeDays > 0) {
            const trendX = [];
            const trendY = [];
            const startNum = laggingTrend.startDate.getTime() / (1000 * 60 * 60 * 24);
            const endNum = laggingTrend.endDate.getTime() / (1000 * 60 * 60 * 24);
            for (let d = startNum; d <= endNum; d += 7) {
                trendX.push(new Date(d * 24 * 60 * 60 * 1000));
                trendY.push(Math.exp(laggingTrend.slope * d + laggingTrend.intercept));
            }
            traces.push({
                x: trendX, y: trendY,
                mode: 'lines', type: 'scatter',
                name: `${laggingLabel} trend`,
                line: { color: laggingColor, width: 2, dash: 'dash' },
                opacity: 0.6,
                showlegend: false
            });
        }

        const title = isOpenClosed ? 'Open vs Closed Model Performance' : 'US vs China Model Performance';

        const layout = {
            title: { text: title, font: { size: 16 } },
            xaxis: {
                title: 'Release Date',
                gridcolor: 'rgba(128,128,128,0.2)'
            },
            yaxis: {
                title: 'Time Horizon (hours)',
                type: 'log',
                gridcolor: 'rgba(128,128,128,0.2)',
                tickvals: [0.01, 0.1, 0.5, 1, 2, 4, 8, 24, 48, 168],
                ticktext: ['36s', '6m', '30m', '1h', '2h', '4h', '8h', '1d', '2d', '1w']
            },
            legend: { orientation: 'h', y: 1.1 },
            hovermode: 'closest',
            plot_bgcolor: 'white',
            paper_bgcolor: 'white',
            height: 400
        };

        Plotly.newPlot('gapPlot', traces, layout, { responsive: true });
    }

    function updateGapStats(data, framing, metric) {
        const isOpenClosed = framing === 'open_closed';
        const groupKey = isOpenClosed ? 'isOpen' : 'isChina';
        const leadingValue = false;

        const leadingLabel = isOpenClosed ? 'Closed' : 'US';
        const laggingLabel = isOpenClosed ? 'Open' : 'Chinese';

        // Update table headers
        document.getElementById('gapLeadingHeader').textContent = `${leadingLabel} Model`;
        document.getElementById('gapLaggingHeader').textContent = `${laggingLabel} Model`;

        // Calculate gaps
        const gaps = calculateHorizontalGaps(data, groupKey, leadingValue);
        const stats = calculateGapStatistics(gaps);
        const verticalGap = calculateVerticalGap(data, groupKey, leadingValue);
        const currentGapEstimate = estimateCurrentGap(gaps);

        // Calculate trends
        const leadingData = data.filter(d => d[groupKey] === leadingValue);
        const laggingData = data.filter(d => d[groupKey] !== leadingValue);
        const leadingTrend = calculateGroupTrend(leadingData);
        const laggingTrend = calculateGroupTrend(laggingData);

        // Update gap metric label and show/hide explainer
        const isCurrentMetric = metric === 'current';
        document.getElementById('gapMetricLabel').textContent = isCurrentMetric ? 'Current Gap (Est.)' : 'Average Gap';
        document.getElementById('currentGapExplainer').style.display = isCurrentMetric ? 'block' : 'none';

        // Update stats cards based on selected metric
        if (isCurrentMetric) {
            // Show estimated current gap
            document.getElementById('gapAvg').textContent = `${currentGapEstimate.estimatedCurrentGap.toFixed(1)} months`;
            document.getElementById('gapAvgDetail').textContent =
                `Min bound: ${currentGapEstimate.minCurrentGap.toFixed(1)} months`;

            const confidenceColors = { high: '#16a34a', medium: '#d97706', low: '#dc2626' };
            document.getElementById('gapAvgExplainer').innerHTML =
                `<span style="color: ${confidenceColors[currentGapEstimate.confidence]};">` +
                `Confidence: ${currentGapEstimate.confidence}</span>` +
                (currentGapEstimate.priorParams ?
                    ` ¬∑ Prior mean: ${currentGapEstimate.priorParams.priorMeanMonths.toFixed(1)} mo` : '');

            document.getElementById('gapMinBound').innerHTML =
                `<strong>Minimum bound:</strong> ${currentGapEstimate.minCurrentGap.toFixed(1)} months ‚Äî ` +
                `the gap cannot be shorter than the oldest unmatched model.`;
        } else {
            // Show average gap
            if (stats.avgGapMonths !== null) {
                document.getElementById('gapAvg').textContent = `${stats.avgGapMonths.toFixed(1)} months`;
                document.getElementById('gapAvgDetail').textContent =
                    `¬±${stats.stdGapMonths.toFixed(1)} mo std dev`;
                document.getElementById('gapAvgExplainer').textContent =
                    `Range: ${stats.minGapMonths.toFixed(1)} ‚Äì ${stats.maxGapMonths.toFixed(1)} months`;
            } else {
                document.getElementById('gapAvg').textContent = 'N/A';
                document.getElementById('gapAvgDetail').textContent = 'No matched gaps yet';
                document.getElementById('gapAvgExplainer').textContent = '';
            }
        }

        if (verticalGap.gapRatio !== null) {
            document.getElementById('gapRatio').textContent = `${verticalGap.gapRatio.toFixed(1)}x`;
            document.getElementById('gapRatioDetail').textContent =
                `${leadingLabel}: ${formatHours(verticalGap.bestLeadingHorizon)} vs ${laggingLabel}: ${formatHours(verticalGap.bestLaggingHorizon)}`;
        } else {
            document.getElementById('gapRatio').textContent = 'N/A';
            document.getElementById('gapRatioDetail').textContent = '';
        }

        document.getElementById('gapMatched').textContent = `${stats.totalMatched} / ${stats.totalUnmatched}`;
        document.getElementById('gapMatchedDetail').textContent =
            `${stats.totalMatched} matched, ${stats.totalUnmatched} unmatched`;

        if (leadingTrend && laggingTrend && leadingTrend.doublingTimeDays > 0 && laggingTrend.doublingTimeDays > 0) {
            const ratio = leadingTrend.doublingTimeDays / laggingTrend.doublingTimeDays;
            if (ratio > 1) {
                document.getElementById('gapTrend').textContent = `${ratio.toFixed(1)}x faster`;
                document.getElementById('gapTrendDetail').textContent =
                    `${laggingLabel} improving faster (${laggingTrend.doublingTimeDays.toFixed(0)}d vs ${leadingTrend.doublingTimeDays.toFixed(0)}d doubling)`;
            } else {
                document.getElementById('gapTrend').textContent = `${(1/ratio).toFixed(1)}x faster`;
                document.getElementById('gapTrendDetail').textContent =
                    `${leadingLabel} improving faster (${leadingTrend.doublingTimeDays.toFixed(0)}d vs ${laggingTrend.doublingTimeDays.toFixed(0)}d doubling)`;
            }
        } else {
            document.getElementById('gapTrend').textContent = 'N/A';
            document.getElementById('gapTrendDetail').textContent = 'Insufficient data';
        }

        // Update gap table
        const gapTableBody = document.getElementById('gapTableBody');
        gapTableBody.innerHTML = gaps.map(gap => `
            <tr style="border-bottom: 1px solid #f1f5f9;">
                <td style="padding: 0.5rem; font-weight: 500;">${gap.leadingModel}</td>
                <td style="padding: 0.5rem;">${formatDate(gap.leadingDate)}</td>
                <td style="padding: 0.5rem; text-align: right; font-family: monospace;">${formatHours(gap.leadingHorizon)}</td>
                <td style="padding: 0.5rem; font-weight: 500;">${gap.laggingModel || '‚Äî'}</td>
                <td style="padding: 0.5rem;">${gap.laggingDate ? formatDate(gap.laggingDate) : 'Not matched'}</td>
                <td style="padding: 0.5rem; text-align: right; font-family: monospace; color: ${gap.matched ? '#16a34a' : '#dc2626'};">
                    ${gap.gapMonths.toFixed(1)} mo${gap.matched ? '' : '+'}
                </td>
            </tr>
        `).join('');

        // Update classification table
        const classTableBody = document.getElementById('classificationTableBody');
        const sorted = [...data].sort((a, b) => b.date - a.date);
        classTableBody.innerHTML = sorted.map(d => {
            const color = FAMILY_COLORS[d.family] || '#999';
            return `
                <tr style="border-bottom: 1px solid #f1f5f9;">
                    <td style="padding: 0.5rem; font-weight: 500;">${d.name}</td>
                    <td style="padding: 0.5rem;">
                        <span style="display: inline-flex; align-items: center; gap: 0.4rem;">
                            <span style="width: 8px; height: 8px; border-radius: 50%; background: ${color};"></span>
                            ${d.family}
                        </span>
                    </td>
                    <td style="padding: 0.5rem; color: ${d.isOpen ? '#2563eb' : '#64748b'};">
                        ${d.isOpen ? 'Open' : 'Closed'}
                    </td>
                    <td style="padding: 0.5rem;">${d.country}</td>
                    <td style="padding: 0.5rem; text-align: right; font-family: monospace;">${formatHours(d.horizon)}</td>
                </tr>
            `;
        }).join('');
    }

    function updateGapAnalysis(data) {
        createGapPlot(data, currentGapFraming);
        updateGapStats(data, currentGapFraming, currentGapMetric);
    }

    // ============================================
    // MAIN
    // ============================================

    let rawData = null;
    let currentData = null;
    let currentAnalysis = null;

    async function loadData() {
        const primaryUrl = 'https://metr.org/assets/benchmark_results.yaml';
        // Local fallback - if you cache the YAML locally (e.g., via GitHub Action or cron)
        const localFallback = './benchmark_results.yaml';

        const sources = [
            // 1. Try local cached copy first (same-origin, no CORS)
            { url: localFallback, name: 'local cache' },
            // 2. Try direct fetch (works if METR adds CORS headers)
            { url: primaryUrl, name: 'direct' },
            // 3. CORS proxies as fallback
            { url: `https://api.allorigins.win/raw?url=${encodeURIComponent(primaryUrl)}`, name: 'allorigins proxy' },
            { url: `https://corsproxy.io/?${encodeURIComponent(primaryUrl)}`, name: 'corsproxy' },
        ];

        for (const source of sources) {
            try {
                const response = await fetch(source.url);
                if (response.ok) {
                    const text = await response.text();
                    // Validate it's actually YAML
                    if (text.includes('benchmark_name') || text.includes('results')) {
                        rawData = jsyaml.load(text);
                        console.log(`Data loaded via ${source.name}`);
                        refresh();
                        return;
                    }
                }
            } catch (error) {
                console.log(`Failed to load from ${source.name}:`, error.message);
                continue;
            }
        }

        document.getElementById('plot').innerHTML =
            `<div class="loading" style="color: #ef4444;">
                Error loading data from all sources.<br>
                <a href="${primaryUrl}" target="_blank">Download YAML manually</a> and save as benchmark_results.yaml
            </div>`;
    }

    function refresh() {
        if (!rawData) return;

        // Clear loading message
        document.getElementById('plot').innerHTML = '';

        const horizonType = document.getElementById('horizonType').value;
        const fitStartDate = new Date(document.getElementById('fitStartDate').value);
        const endYear = parseInt(document.getElementById('endYear').value);
        const showCI = document.getElementById('showCI').checked;
        const showProjection = document.getElementById('showProjection').checked;
        const showBootstrap = document.getElementById('showBootstrap').checked;

        const customScenarios = [
            parseFloat(document.getElementById('custom1').value) || 0,
            parseFloat(document.getElementById('custom2').value) || 0,
            parseFloat(document.getElementById('custom3').value) || 0
        ];

        // Parse all data
        const allData = parseYAMLData(rawData, horizonType);

        // Filter for fitting
        const fitData = allData.filter(d => d.date >= fitStartDate);

        if (fitData.length < 4) {
            document.getElementById('plot').innerHTML =
                '<div class="loading">Not enough data points for analysis. Adjust the fit start date.</div>';
            return;
        }

        // Run analysis
        currentData = allData;
        currentAnalysis = analyzeData(fitData, showBootstrap ? 2000 : 100);
        const oosResult = outOfSampleTest(fitData);

        // Update UI
        createPlot(allData, currentAnalysis, {
            showCI,
            showProjection,
            showBootstrap,
            endYear,
            customScenarios
        });

        updateStats(currentAnalysis, fitData, oosResult);
        updateModelSelectors(allData);
        updateModelCalc(allData, horizonType);
        updateMilestoneCalc(currentAnalysis, fitData);
        updateRawDataTable(allData);
        updateGapAnalysis(allData);
    }

    // Event listeners
    document.addEventListener('DOMContentLoaded', () => {
        loadData();

        // Control changes
        ['horizonType', 'fitStartDate', 'endYear', 'showCI', 'showProjection', 'showBootstrap'].forEach(id => {
            document.getElementById(id).addEventListener('change', refresh);
        });

        // Custom scenarios (debounced)
        let debounceTimer;
        ['custom1', 'custom2', 'custom3'].forEach(id => {
            document.getElementById(id).addEventListener('input', () => {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(refresh, 300);
            });
        });

        // Calculator tabs (only for tabs with data-tab attribute, not gap analysis tabs)
        document.querySelectorAll('[data-tab]').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('[data-tab]').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(`${tab.dataset.tab}-tab`).classList.add('active');
            });
        });

        // Model calculator
        ['model1', 'model2'].forEach(id => {
            document.getElementById(id).addEventListener('change', () => {
                updateModelCalc(currentData, document.getElementById('horizonType').value);
            });
        });

        // Date calculator
        ['calcStartDate', 'calcEndDate'].forEach(id => {
            document.getElementById(id).addEventListener('change', () => {
                updateDateCalc(currentData);
            });
        });

        // Milestone calculator
        document.getElementById('targetHorizon').addEventListener('change', () => {
            if (currentAnalysis && currentData) {
                const fitStartDate = new Date(document.getElementById('fitStartDate').value);
                const fitData = currentData.filter(d => d.date >= fitStartDate);
                updateMilestoneCalc(currentAnalysis, fitData);
            }
        });

        // Gap analysis tabs
        document.querySelectorAll('[data-gap-tab]').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('[data-gap-tab]').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                currentGapFraming = tab.dataset.gapTab;
                if (currentData) {
                    updateGapAnalysis(currentData);
                }
            });
        });

        // Gap metric toggle
        document.querySelectorAll('[data-gap-metric]').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('[data-gap-metric]').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                currentGapMetric = tab.dataset.gapMetric;
                if (currentData) {
                    updateGapAnalysis(currentData);
                }
            });
        });
    });
    </script>
</body>
</html>
